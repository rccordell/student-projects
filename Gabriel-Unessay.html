<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Library of SHRDLU</title>
  <style>
    :root {
      --bg1: #0b1224;
      --bg2: #0f172a;
      --bg3: #0a0f1f;
      --panel: #111827;
      --border: #1f2937;
      --accent: #e0f2fe;
      --accent-soft-1: rgba(56, 189, 248, 0.15);
      --accent-soft-2: rgba(14, 165, 233, 0.12);
      --text: #e5e7eb;
      --muted: #9ca3af;
      --shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
      --radius: 12px;
      --cell-size: clamp(56px, 9vw, 88px);
      --gap: 12px;
      --row-gap: 16px;
      --data-cols: 5;
      --prompt-cols: 5;
      --surface-1: #0c1324;
      --surface-2: #0e1a32;
      --row-start: #0d162a;
      --row-end: #0b1224;
      --cell-start: #111827;
      --cell-end: #0b1222;
      --empty-start: #0c1324;
      --empty-end: #0a101c;
      --font-title: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      --font-body: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background: radial-gradient(circle at 20% 20%, var(--bg1) 0, var(--bg2) 45%, var(--bg3) 100%);
      color: var(--text);
      font-family: var(--font-body);
      padding: 32px clamp(16px, 4vw, 48px);
    }

    .frame {
      width: min(1080px, 100%);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: clamp(20px, 4vw, 32px);
      position: relative;
    }

    .mode-bar {
      display: flex;
      gap: 10px;
      justify-content: flex-start;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .pill-btn {
      border: none;
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #0b1020;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      transition: transform 140ms ease, filter 140ms ease;
    }

    .pill-btn:hover,
    .pill-btn:focus-visible {
      transform: translateY(-1px);
      filter: brightness(1.05);
      outline: none;
    }

    .pill-btn:active { transform: translateY(0); }

    .pill-markov { background: #34d399; }
    .pill-turing { background: #38bdf8; }
    .pill-cordell { background: #fb923c; }
    .pill-dev { background: #cbd5e1; color: #0b1020; font-size: 12px; padding: 8px 10px; box-shadow: none; }

    .control-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 12px;
    }

    .difficulty-label {
      margin: 0 0 6px;
      font-size: 13px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .symbol-switcher {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .symbol-label {
      font-size: 12px;
      letter-spacing: 0.08em;
      color: var(--muted);
      text-transform: uppercase;
    }

    .symbol-toggle {
      display: inline-flex;
      gap: 6px;
      background: var(--surface-1);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 3px;
    }

    .symbol-btn {
      border: none;
      background: transparent;
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.04em;
      padding: 6px 10px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 140ms ease, color 140ms ease;
    }

    .symbol-btn.is-active {
      background: var(--surface-2);
      color: var(--accent);
    }

    .generate-btn {
      border: 1px solid var(--border);
      background: var(--surface-1);
      color: var(--accent);
      font-weight: 800;
      letter-spacing: 0.1em;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
      text-transform: uppercase;
    }

    .generate-btn:hover,
    .generate-btn:focus-visible {
      transform: translateY(-1px);
      border-color: var(--accent);
      background: var(--surface-2);
      outline: none;
    }

    .dev-toggle {
      position: absolute;
      right: 12px;
      bottom: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .dev-menu {
      position: absolute;
      right: 12px;
      bottom: 56px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px;
      display: none;
      gap: 10px;
      min-width: 220px;
      z-index: 12;
    }

    .dev-menu.is-open { display: grid; }

    .dev-menu label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 12px;
      color: var(--muted);
      gap: 8px;
    }

    .dev-menu input {
      width: 72px;
      padding: 6px 8px;
      background: var(--surface-1);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
    }

    h1 {
      margin: 0 0 24px;
      font-family: var(--font-title);
      font-weight: 800;
      font-size: clamp(32px, 6vw, 56px);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      color: var(--accent);
    }

    .section-title {
      margin: 0 0 12px;
      font-size: 14px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .data-grid {
      display: flex;
      flex-direction: column;
      gap: var(--row-gap);
      align-items: center;
      margin-bottom: 28px;
      user-select: none;
      -webkit-user-select: none;
    }

    .data-row {
      display: grid;
      grid-template-columns: repeat(var(--data-cols), var(--cell-size));
      column-gap: var(--gap);
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: calc(var(--radius) + 4px);
      background: linear-gradient(150deg, var(--row-start), var(--row-end));
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 10px 24px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: translateY(8px) scale(0.98);
      transition: opacity 220ms ease, transform 220ms ease, box-shadow 220ms ease;
      position: relative;
      overflow: visible;
      user-select: none;
    }

    .data-row.is-visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .symbol-cell {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: linear-gradient(145deg, var(--cell-start), var(--cell-end));
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(20px, 5vw, 32px);
      color: var(--accent);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 8px 18px rgba(0, 0, 0, 0.25);
      user-select: none;
      -webkit-user-select: none;
      opacity: 0;
      transform: translateY(6px) scale(0.96);
      transition: opacity 220ms ease, transform 220ms ease;
      position: relative;
      z-index: 1;
    }

    .symbol-cell.is-visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .symbol-cell[hidden] { display: none; }

    .symbol-cell.is-selected {
      outline: none;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), 0 8px 18px rgba(0, 0, 0, 0.25);
    }

    .selection-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
      z-index: 0;
    }

    .selection-band {
      position: absolute;
      top: 50%;
      left: 50%;
      height: calc(var(--cell-size) + 8px);
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.55);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.14), 0 6px 16px rgba(0, 0, 0, 0.24);
      border-radius: 12px;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.7);
      transform-origin: center center;
      will-change: transform, opacity, left, top, width, height;
      transition:
        opacity 220ms cubic-bezier(0.22, 0.61, 0.36, 1),
        transform 240ms cubic-bezier(0.22, 0.61, 0.36, 1),
        left 240ms cubic-bezier(0.22, 0.61, 0.36, 1),
        width 240ms cubic-bezier(0.22, 0.61, 0.36, 1),
        height 240ms cubic-bezier(0.22, 0.61, 0.36, 1),
        top 240ms cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    .prompt-section {
      position: relative;
    }

    .prompt-row {
      display: grid;
      grid-template-columns: repeat(var(--prompt-cols), var(--cell-size));
      gap: var(--gap);
      justify-content: center;
      align-items: center;
    }

    .extra-row-control {
      margin: 14px auto 6px;
      display: flex;
      justify-content: center;
    }

    .extra-row-btn {
      border: 1px solid var(--border);
      background: var(--surface-1);
      color: var(--accent);
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
      letter-spacing: 0.06em;
    }

    .extra-row-btn:hover,
    .extra-row-btn:focus-visible {
      transform: translateY(-1px);
      border-color: var(--accent-current, #38bdf8);
      background: var(--surface-2);
      outline: none;
    }

    .choices {
      margin-top: 16px;
      display: grid;
      gap: 10px;
      justify-content: center;
    }

    .choices-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(56px, 72px));
      gap: 10px;
      justify-content: center;
    }

    .choice-btn {
      border: 1px solid var(--border);
      background: var(--surface-1);
      color: var(--accent);
      font-weight: 800;
      letter-spacing: 0.1em;
      padding: 14px 0;
      font-size: 22px;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
    }

    .choice-btn:hover,
    .choice-btn:focus-visible {
      border-color: var(--accent-current, #38bdf8);
      background: var(--surface-2);
      transform: translateY(-1px);
      outline: none;
    }

    .choice-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .feedback {
      min-height: 22px;
      text-align: center;
      color: var(--accent);
      font-weight: 600;
      opacity: 0;
      transition: opacity 380ms ease;
    }

    .feedback.show {
      opacity: 1;
    }

    @keyframes fadeAway {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }

    .feedback.fade {
      animation: fadeAway 900ms ease forwards;
    }

    @keyframes flashGreen {
      0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.55); }
      50% { box-shadow: 0 0 0 12px rgba(16, 185, 129, 0.0); }
      100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
    }

    @keyframes flashRed {
      0% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.55); }
      50% { box-shadow: 0 0 0 12px rgba(248, 113, 113, 0.0); }
      100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0); }
    }

    .flash-correct { animation: flashGreen 550ms ease; }
    .flash-wrong { animation: flashRed 550ms ease; }

    .accent-markov {
      --bg1: #07130c;
      --bg2: #0c1d14;
      --bg3: #051009;
      --panel: #0e1a12;
      --border: #153024;
      --accent: #d3f5e3;
      --accent-current: #34d399;
      --accent-soft-1: rgba(52, 211, 153, 0.18);
      --accent-soft-2: rgba(16, 185, 129, 0.14);
      --muted: #8caf9d;
      --surface-1: #0d1b14;
      --surface-2: #102417;
      --row-start: #0b1a12;
      --row-end: #08140e;
      --cell-start: #102017;
      --cell-end: #0a1a12;
      --empty-start: #0c1a12;
      --empty-end: #08140d;
    }

    .accent-turing {
      --bg1: #0b1224;
      --bg2: #0f172a;
      --bg3: #0a0f1f;
      --panel: #111827;
      --border: #1f2937;
      --accent: #e0f2fe;
      --accent-current: #38bdf8;
      --accent-soft-1: rgba(56, 189, 248, 0.15);
      --accent-soft-2: rgba(14, 165, 233, 0.12);
      --muted: #9ca3af;
      --surface-1: #0c1324;
      --surface-2: #0e1a32;
      --row-start: #0d162a;
      --row-end: #0b1224;
      --cell-start: #111827;
      --cell-end: #0b1222;
      --empty-start: #0c1324;
      --empty-end: #0a101c;
    }

    .accent-cordell {
      --bg1: #1f0f06;
      --bg2: #2a1509;
      --bg3: #150903;
      --panel: #1b120c;
      --border: #331a0f;
      --accent: #ffe8d1;
      --accent-current: #fb923c;
      --accent-soft-1: rgba(251, 146, 60, 0.2);
      --accent-soft-2: rgba(234, 88, 12, 0.14);
      --muted: #c8a88c;
      --surface-1: #241309;
      --surface-2: #2c180c;
      --row-start: #25160c;
      --row-end: #1a0f08;
      --cell-start: #2a190d;
      --cell-end: #1e1209;
      --empty-start: #211409;
      --empty-end: #150c06;
    }

    .symbol-cell.is-preset {
      border-color: var(--accent-current, #38bdf8);
      background: linear-gradient(145deg, var(--accent-soft-1), var(--accent-soft-2));
      color: var(--accent);
    }

    .symbol-cell.is-empty {
      border-style: dashed;
      color: var(--muted);
      background: linear-gradient(145deg, var(--empty-start), var(--empty-end));
    }

    .symbol-cell.is-active-blank {
      border-color: var(--accent-current, var(--accent));
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.18), 0 0 12px rgba(255, 255, 255, 0.24);
    }

    @media (max-width: 640px) {
      :root {
        --cell-size: clamp(52px, 15vw, 70px);
        --gap: 10px;
        --row-gap: 12px;
      }

      .frame { padding: 20px; }
      h1 { letter-spacing: 0.06em; }
    }
  </style>
</head>
  <body>
    <main class="frame" aria-label="The Library of SHRDLU">
      <div class="control-header">
        <div>
          <p class="difficulty-label">Select Difficulty</p>
          <div class="mode-bar" aria-label="Mode buttons">
            <button class="pill-btn pill-markov" type="button" data-action="markov">Markov</button>
            <button class="pill-btn pill-turing" type="button" data-action="turing">Turing</button>
            <button class="pill-btn pill-cordell" type="button" data-action="cordell">Cordell</button>
          </div>
          <button class="generate-btn" type="button" data-action="generate">Generate Puzzle</button>
        </div>
        <div class="symbol-switcher" aria-label="Symbol set selector">
          <span class="symbol-label">Symbols</span>
          <div class="symbol-toggle" role="group" aria-label="Symbol set">
            <button class="symbol-btn is-active" type="button" data-symbol="geometric">Geometric</button>
            <button class="symbol-btn" type="button" data-symbol="runic">Runic</button>
          </div>
        </div>
      </div>
      <h1>THE LIBRARY OF SHRDLU</h1>

    <section aria-labelledby="data-heading">
      <p id="data-heading" class="section-title">Data</p>
      <div class="data-grid" role="grid" aria-label="Data grid" data-grid></div>
      <div class="extra-row-control">
        <button class="extra-row-btn" type="button" data-add-row>Request additional data</button>
      </div>
    </section>

    <section aria-labelledby="prompt-heading" class="prompt-section" data-prompt-section>
      <p id="prompt-heading" class="section-title">Prompt</p>
      <div class="prompt-row" role="list" aria-label="Prompt symbols" data-prompt>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 1"></div>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 2"></div>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 3"></div>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 4"></div>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 5"></div>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 6"></div>
        <div class="symbol-cell is-preset" role="listitem" aria-label="Prompt symbol 7"></div>
      </div>
      <div class="choices" aria-live="polite">
        <p class="section-title" id="choice-heading">Choose Next Symbol</p>
      <div class="choices-grid" role="list" aria-labelledby="choice-heading" data-choices>
        <button class="choice-btn" type="button" data-choice role="listitem"></button>
        <button class="choice-btn" type="button" data-choice role="listitem"></button>
        <button class="choice-btn" type="button" data-choice role="listitem"></button>
        <button class="choice-btn" type="button" data-choice role="listitem"></button>
        <button class="choice-btn" type="button" data-choice role="listitem" data-choice-extra></button>
        <button class="choice-btn" type="button" data-choice role="listitem" data-choice-extra-cordell></button>
      </div>
        <p class="feedback" data-feedback></p>
      </div>
    </section>
    <div class="dev-toggle">
      <button class="pill-btn pill-dev" type="button" data-action="dev-menu">Developer Options</button>
    </div>
    <div class="dev-menu" data-dev-menu>
      <label>View
        <select data-dev-view>
          <option value="symbols">Symbols</option>
          <option value="letters">Base Letters</option>
        </select>
      </label>
      <label>Seq %
        <input type="number" min="0" max="1" step="0.01" data-dev-seq title="0-1 fraction per row" />
        <span class="dev-default" data-dev-seq-default></span>
      </label>
      <label>Mutation %
        <input type="number" min="0" max="1" step="0.01" data-dev-mut title="0-1 fraction per sequence" />
        <span class="dev-default" data-dev-mut-default></span>
      </label>
      <label class="checkbox-row">
        Cheating sequence generation
        <input type="checkbox" data-dev-cheat />
      </label>
      <button class="pill-btn pill-dev" type="button" data-action="apply-dev">Apply to future generations</button>
    </div>
  </main>

  <script type="module">
    const defaultPromptLetters = ["A", "B", "C", "D", "E"];
    const turingPromptLetters = ["A", "B", "C", "D", "E", "F"];
    const cordellPromptLetters = ["A", "B", "C", "D", "E", "F", "G"];
    let currentPromptLetters = [...defaultPromptLetters];
    let sequences = [];
    let sequenceUsage = new Map();
    let sequenceAdjust = new Map();
    const alphabet = "ABCDEFGHIJKLMNO";
    const promptCells = Array.from(document.querySelectorAll('[data-prompt] .symbol-cell'));
    promptCells.forEach((cell, idx) => {
      cell.classList.add("is-visible");
      cell.textContent = "";
      cell.setAttribute("aria-label", `Prompt slot ${idx + 1}`);
    });

    const dataGrid = document.querySelector('[data-grid]');
    const addRowBtn = document.querySelector('[data-add-row]');

    const defaultBaseRows = 4;
    const defaultColumns = 5;
    const turingBaseRows = 5;
    const turingColumns = 6;
    let baseRows = defaultBaseRows;
    let columns = defaultColumns;
    let promptSlots = 5;
    const cellDelay = 80; // ms between cells in a row
    const rowPauseBetween = 200; // ms wait after a row completes
    const getRowStepDelay = () => cellDelay * columns + rowPauseBetween; // total spacing between row starts
    const extraRowDelay = 200; // ms pause before rendering added rows

    const symbolSets = {
      geometric: "□▣▦▲▽◆◈◊✖✜✶⟡⩄⩀⌔⋈⊓◎◉".split(""),
      runic: "ᚠᚤᚦᚬᚱᚻᚼᛄᛒᛗᛘᛝᛞᛟᛡᛥᛤᛪᛨᛯᛰ".split(""),
    };
    let gridCells = [];
    let rowCount = baseRows;
    let currentSymbolMap = {};
    let currentSymbolPool = symbolSets.geometric;
    let selectedSymbolSet = "geometric";
    let devMode = false;
    let cheatSeqGeneration = true;
    let customSeqChance = null;
    let customMutateChance = null;
    let currentBoard = [];
    let currentAccent = "markov";
    let rowAddQueue = Promise.resolve();
    let generationId = 0;
    let activeGenerationId = 0;
    let symbolIndexMap = {};
    let isDraggingSelection = false;
    let dragPointerId = null;
    let dragSelectionMode = "add";
    let dragRow = null;
    let blankTargets = [3, 4];

    function revealRow(row) {
      row.hidden = false;
      row.classList.remove("is-visible");
      // ensure the browser registers initial state before transition
      requestAnimationFrame(() => {
        row.getBoundingClientRect();
        row.classList.add("is-visible");
      });
    }

    function buildSymbolIndexMap() {
      // Bias against duplicate symbols: reroll one time if we collide, then accept.
      const pool = currentSymbolPool || symbolSets[selectedSymbolSet] || symbolSets.geometric;
      if (!pool?.length) return;
      symbolIndexMap = {};
      const used = new Set();
      for (const letter of alphabet) {
        let idx = Math.floor(Math.random() * pool.length * 3 + Math.random() * pool.length);
        let symIdx = idx % pool.length;
        if (used.has(symIdx)) {
          const retryIdx = Math.floor(Math.random() * pool.length * 3 + Math.random() * pool.length);
          const retrySymIdx = retryIdx % pool.length;
          if (!used.has(retrySymIdx)) {
            symIdx = retrySymIdx;
            idx = retryIdx;
          } else {
            symIdx = retrySymIdx; // accept duplicate after one reroll
            idx = retryIdx;
          }
        }
        used.add(symIdx);
        symbolIndexMap[letter] = idx;
      }
    }

    function createRow(rowNumber) {
      const row = document.createElement("div");
      row.className = "data-row";
      row.setAttribute("role", "row");
      row.hidden = true;
      const cells = [];
      row.style.setProperty("--data-cols", columns);
      for (let c = 0; c < columns; c++) {
        const cell = document.createElement("div");
        cell.className = "symbol-cell";
        cell.setAttribute("role", "gridcell");
        cell.setAttribute("aria-label", `Row ${rowNumber} Column ${c + 1}`);
        cell.dataset.baseLabel = cell.getAttribute("aria-label");
        cells.push(cell);
        row.appendChild(cell);
      }
      const layer = document.createElement("div");
      layer.className = "selection-layer";
      layer.setAttribute("aria-hidden", "true");
      row.appendChild(layer);
      return { row, cells, layer };
    }

    function initializeGrid() {
      if (!dataGrid) return;
      // rows are created on demand during rendering
    }

    function resetGridToBaseRows() {
      if (!dataGrid) return;
      clearFillTimeouts();
      dataGrid.innerHTML = "";
      rowCount = baseRows;
      gridCells = [];
    }

    function appendRow() {
      rowCount += 1;
      const newRowNumber = rowCount;
      const { row, cells } = createRow(newRowNumber);
      dataGrid.appendChild(row);
      gridCells.push(...cells);
      return { rowIndex: newRowNumber - 1, rowEl: row }; // zero-based index
    }

    function placeSequence(board, seq) {
      if (!seq) return true;
      const maxStart = board.length - seq.length;
      const attempts = 120;
      for (let i = 0; i < attempts; i++) {
        const start = Math.floor(Math.random() * (maxStart + 1));
        let fits = true;
        for (let j = 0; j < seq.length; j++) {
          const existing = board[start + j];
          if (existing && existing !== seq[j]) {
            fits = false;
            break;
          }
        }
        if (!fits) continue;
        for (let j = 0; j < seq.length; j++) {
          board[start + j] = seq[j];
        }
        return true;
      }
      return false;
    }

    function buildBoard() {
      const board = [];
      for (let r = 0; r < rowCount; r++) {
        const letters = generateRowLetters();
        board.push(...letters);
      }
      return board;
    }

    function countSharedLetters(a, b) {
      const setA = new Set(a.split(""));
      let count = 0;
      for (const ch of b) {
        if (setA.has(ch)) count += 1;
      }
      return count;
    }

    function adjustWeightsAfterHit(hitSeq) {
      if (!hitSeq) return;
      const hitRelevant = isPromptRelevantSequence(hitSeq);
      sequences.forEach((seq) => {
        const current = sequenceAdjust.get(seq) || 0;
        if (seq === hitSeq) {
          sequenceAdjust.set(seq, current - 0.6); // punish the picked sequence to diversify
          return;
        }
        const shared = countSharedLetters(hitSeq, seq);
        const unmatched = Math.max(seq.length - shared, 0);
        const baseStep = 0.05;
        const relevant = isPromptRelevantSequence(seq);
        const decFactor = relevant ? 0.5 : 1; // soften decreases for prompt-relevant
        const incFactor = relevant ? 1.5 : 1; // strengthen increases for prompt-relevant
        const delta = unmatched * baseStep * incFactor - shared * baseStep * decFactor;
        sequenceAdjust.set(seq, current + delta);
      });
    }

    function getSymbol(letter) {
      if (devMode) return letter;
      const pool = currentSymbolPool || symbolSets[selectedSymbolSet] || symbolSets.geometric;
      if (!pool?.length) return letter;
      const idx = symbolIndexMap[letter];
      if (idx === undefined) return letter;
      return pool[idx % pool.length];
    }

    function renderBoardInstant(board) {
      board.forEach((letter, idx) => {
        const cell = gridCells[idx];
        if (!cell) return;
        const base = cell.dataset.baseLabel;
        const symbol = getSymbol(letter);
        cell.dataset.letter = letter;
        cell.textContent = symbol;
        cell.setAttribute("aria-label", `${base} contains letter ${letter}, symbol ${symbol}`);
        cell.classList.add("is-visible");
      });
    }

    let fillTimeouts = [];

    function clearFillTimeouts() {
      fillTimeouts.forEach(clearTimeout);
      fillTimeouts = [];
    }

    function animateRenderBoard(board) {
      clearFillTimeouts();
      dataGrid.innerHTML = "";
      gridCells = [];

      for (let row = 0; row < rowCount; row++) {
        const letters = board.slice(row * columns, row * columns + columns);
        const startDelay = row * getRowStepDelay();
        const timeout = setTimeout(() => {
          if (generationId !== activeGenerationId) return;
          // Build the row only when it's ready to render symbols to avoid empty shells.
          const { row: rowEl, cells } = createRow(row + 1);
          dataGrid.appendChild(rowEl);
          gridCells.push(...cells);
          revealRow(rowEl);
          animateRowFill(row, letters, 0);
        }, startDelay);
        fillTimeouts.push(timeout);
      }
    }

    function animateRowFill(rowIndex, letters, startDelay = 0) {
      for (let col = 0; col < columns; col++) {
        const idx = rowIndex * columns + col;
        const letter = letters[col];
        const timeout = setTimeout(() => {
          if (generationId !== activeGenerationId) return;
          const cell = gridCells[idx];
          if (!cell) return;
          const base = cell.dataset.baseLabel;
          const symbol = getSymbol(letter);
          cell.dataset.letter = letter;
          cell.textContent = symbol;
          cell.setAttribute("aria-label", `${base} contains letter ${letter}, symbol ${symbol}`);
          cell.classList.add("is-visible");
        }, startDelay + col * cellDelay);
        fillTimeouts.push(timeout);
      }
    }

    // Choice logic ---------------------------------------------------------
    let stageAnswers = ["D", "E"];
    const choiceButtons = Array.from(document.querySelectorAll('[data-choice]'));
    const feedbackEl = document.querySelector('[data-feedback]');
    const promptSection = document.querySelector('[data-prompt-section]');
    let stageIndex = 0;
    let stages = [];

    function shuffle(list) {
      return list
        .map((item) => ({ item, sort: Math.random() }))
        .sort((a, b) => a.sort - b.sort)
        .map(({ item }) => item);
    }

    function getBoardLetters() {
      return Array.from(new Set(currentBoard.filter(Boolean)));
    }

    function buildOptions(answer) {
      const pool = getBoardLetters();
      if (!pool.includes(answer)) pool.push(answer);
      const desiredCount = currentAccent === "cordell" ? 6 : currentAccent === "turing" ? 5 : 4;
      const options = new Set([answer]);
      const distractors = pool.filter((l) => l !== answer);
      while (options.size < desiredCount && distractors.length) {
        const pick = distractors[Math.floor(Math.random() * distractors.length)];
        options.add(pick);
      }
      while (options.size < desiredCount) {
        const pick = alphabet[Math.floor(Math.random() * alphabet.length)];
        if (pick !== answer) options.add(pick);
      }
      return shuffle([...options]);
    }

    function chooseBlankTargets() {
      if (columns === turingColumns) {
        const slots = [1, 2, 3, 4, 5]; // zero-based positions 2-6
        const picks = shuffle(slots).slice(0, 2).sort((a, b) => a - b);
        blankTargets = picks;
        promptSlots = 6;
        currentPromptLetters = [...turingPromptLetters];
        stageAnswers = blankTargets.map((idx) => currentPromptLetters[idx]).filter(Boolean);
      } else if (columns === 7) {
        const slots = [0, 1, 2, 3, 4, 5, 6];
        const picks = shuffle(slots).slice(0, 3).sort((a, b) => a - b);
        blankTargets = picks;
        promptSlots = 7;
        currentPromptLetters = [...cordellPromptLetters];
        stageAnswers = blankTargets.map((idx) => currentPromptLetters[idx]).filter(Boolean);
      } else {
        blankTargets = [3, 4];
        promptSlots = 5;
        currentPromptLetters = [...defaultPromptLetters];
        stageAnswers = ["D", "E"];
      }
    }

    function updateSequencesForMode() {
      if (currentAccent === "markov") {
        sequences = contiguousSequences(currentPromptLetters, 5);
      } else if (currentAccent === "turing") {
        sequences = contiguousSequences(currentPromptLetters, 6);
      } else {
        sequences = contiguousSequences(currentPromptLetters, 7);
      }
      resetSequenceUsage();
    }

    function isPromptRelevantSequence(seq) {
      if (currentAccent === "markov") return /[DE]/.test(seq);
      if (currentAccent === "turing" || currentAccent === "cordell") {
        return stageAnswers?.some((ch) => seq.includes(ch));
      }
      return false;
    }

    function pickWeightedSequence() {
      if (!sequences.length) return "";
      const usages = sequences.map((seq) => sequenceUsage.get(seq) || 0);
      const minUsage = usages.length ? Math.min(...usages) : 0;
      const targetBlankSet =
        cheatSeqGeneration && (currentAccent === "turing" || currentAccent === "cordell")
          ? new Set(stageAnswers)
          : null;
      const weights = sequences.map((seq, idx) => {
        const use = usages[idx];
        // Scarcity boost grows faster when unused and tapers as usage rises.
        const scarcity = use === 0 ? 2 : (minUsage + 1) / (use + 1);
        let w = 1 + scarcity;
        if (currentAccent === "markov" && /[DE]/.test(seq)) {
          // Extra emphasis on D/E sequences when they lag behind.
          w *= 1.5 + 0.25 * scarcity;
        }
        if (targetBlankSet && seq.split("").some((ch) => targetBlankSet.has(ch))) {
          // Slightly favor sequences that contain current blanks; ramps with scarcity.
          w *= 1.2 + 0.2 * scarcity;
        }
        const adjust = sequenceAdjust.get(seq) || 0;
        return Math.max(0.2, w + adjust);
      });
      const total = weights.reduce((a, b) => a + b, 0);
      let roll = Math.random() * total;
      for (let i = 0; i < sequences.length; i++) {
        roll -= weights[i];
        if (roll <= 0) return sequences[i];
      }
      return sequences[sequences.length - 1];
    }

    function buildStages() {
      return stageAnswers.map((answer, idx) => ({ answer, targetIndex: blankTargets[idx] ?? (3 + idx) }));
    }

    function randomLetter() {
      return alphabet[Math.floor(Math.random() * alphabet.length)];
    }

    function randomFillerLetter() {
      if (currentAccent === "markov" && Math.random() < 0.25) {
        const promptPool = currentPromptLetters;
        return promptPool[Math.floor(Math.random() * promptPool.length)];
      }
      return randomLetter();
    }

    function contiguousSequences(letters, maxLen) {
      const out = new Set();
      const cap = Math.min(maxLen, letters.length);
      for (let len = 2; len <= cap; len++) {
        for (let i = 0; i <= letters.length - len; i++) {
          out.add(letters.slice(i, i + len).join(""));
        }
      }
      return Array.from(out);
    }

    function resetSequenceUsage() {
      sequenceUsage = new Map();
      sequences.forEach((seq) => sequenceUsage.set(seq, 0));
      sequenceAdjust = new Map();
    }

    function sanitizeSequenceForPrompt(seq) {
      if (!seq || !seq.includes("X")) return seq;
      const promptPool = currentPromptLetters;
      return seq
        .split("")
        .map((ch) => (ch === "X" ? promptPool[Math.floor(Math.random() * promptPool.length)] : ch))
        .join("");
    }

    function ensureAnswersPresent(board) {
      if (!Array.isArray(board)) return;
      const needed = new Map();
      currentPromptLetters.slice(0, promptSlots).forEach((ltr) => {
        needed.set(ltr, (needed.get(ltr) || 0) + 2);
      });
      board.forEach((ch) => {
        if (needed.has(ch)) needed.set(ch, Math.max(0, needed.get(ch) - 1));
      });
      needed.forEach((count, letter) => {
        for (let i = 0; i < count; i++) {
          const idx = Math.floor(Math.random() * board.length);
          board[idx] = letter;
        }
      });
    }

    function ensureNoiseDiversity(board) {
      if (!Array.isArray(board)) return;
      const unique = new Set(board.filter(Boolean));
      const need = Math.max(0, 4 - unique.size);
      for (let i = 0; i < need; i++) {
        const idx = Math.floor(Math.random() * board.length);
        board[idx] = randomFillerLetter();
      }
    }

    function generateRowLetters() {
      const row = Array(columns).fill(null);
      const defaultSeq = currentAccent === "markov" ? 0.5 : currentAccent === "turing" ? 0.4 : 0.4;
      const seqChance = typeof customSeqChance === "number" ? customSeqChance : defaultSeq;
      let seq = Math.random() < seqChance ? pickWeightedSequence() : "";
      seq = sanitizeSequenceForPrompt(seq);
      const defaultMutate = currentAccent === "turing" ? 0.25 : currentAccent === "cordell" ? 0.35 : 0.15;
      const mutateChance = typeof customMutateChance === "number" ? customMutateChance : defaultMutate;
      if (seq && seq.length > 2 && Math.random() < mutateChance) {
        const chars = seq.split("");
        const mutateIdx = Math.floor(Math.random() * (chars.length - 1)) + 1; // avoid first for clarity
        chars[mutateIdx] = randomLetter();
        seq = chars.join("");
      }
      if (seq && seq.length <= columns) {
        const start = Math.floor(Math.random() * (columns + 1 - seq.length));
        for (let i = 0; i < seq.length; i++) row[start + i] = seq[i];
        sequenceUsage.set(seq, (sequenceUsage.get(seq) || 0) + 1);
        adjustWeightsAfterHit(seq);
      }
      for (let i = 0; i < row.length; i++) {
        if (!row[i]) row[i] = randomFillerLetter();
      }
      return row;
    }

    function updatePromptCell(index, letter) {
      const cell = promptCells[index];
      const symbol = getSymbol(letter);
      cell.dataset.letter = letter;
      cell.textContent = symbol;
      cell.classList.remove("is-empty");
      cell.classList.add("is-preset");
      cell.classList.add("is-visible");
      cell.setAttribute("aria-label", `Prompt symbol ${letter}, symbol ${symbol}`);
    }

    function showFeedback(message, fade = true) {
      if (!feedbackEl) return;
      if (!message) {
        feedbackEl.textContent = "";
        feedbackEl.classList.remove("show", "fade");
        return;
      }
      feedbackEl.textContent = message;
      feedbackEl.classList.add("show");
      if (fade) {
        feedbackEl.classList.add("fade");
        setTimeout(() => {
          feedbackEl.classList.remove("show", "fade");
          feedbackEl.textContent = "";
        }, 1000);
      }
    }

    function setOptions(answer) {
      const options = buildOptions(answer);
      choiceButtons.forEach((btn) => {
        const isExtra = btn.hasAttribute("data-choice-extra");
        const isExtraCordell = btn.hasAttribute("data-choice-extra-cordell");
        const shouldShow = currentAccent === "turing"
          ? !isExtraCordell
          : currentAccent === "cordell"
          ? true
          : !isExtra && !isExtraCordell;
        btn.hidden = !shouldShow;
        btn.style.display = shouldShow ? "block" : "none";
      });
      choiceButtons.forEach((btn, i) => {
        btn.disabled = false;
        const letter = options[i];
        const symbol = getSymbol(letter);
        btn.textContent = symbol;
        btn.dataset.letter = letter;
        btn.setAttribute("aria-label", `Option ${letter}, symbol ${symbol}`);
      });
      showFeedback("");
    }

    function applyLayoutVars() {
      document.documentElement.style.setProperty("--data-cols", columns);
      document.documentElement.style.setProperty("--prompt-cols", promptSlots);
    }

    function disableChoices() {
      choiceButtons.forEach((btn) => (btn.disabled = true));
    }

    function clearPromptFlashes() {
      promptCells.forEach((cell) => cell.classList.remove("flash-correct", "flash-wrong"));
    }

    function flashPrompt(type) {
      const stage = stages[stageIndex];
      if (!stage) return;
      clearPromptFlashes();
      const targetIdx = stage.targetIndex;
      const cell = promptCells[targetIdx];
      if (!cell) return;
      markActiveBlank();
      cell.classList.remove("flash-correct", "flash-wrong");
      void cell.offsetWidth;
      cell.classList.add(type === "correct" ? "flash-correct" : "flash-wrong");
    }

    function setPromptBase() {
      const availableLetters = [...currentPromptLetters];
      for (let i = 0; i < promptCells.length; i++) {
        const cell = promptCells[i];
        const isActive = i < promptSlots;
        cell.hidden = !isActive;
        if (!isActive) {
          cell.textContent = "";
          delete cell.dataset.letter;
          cell.classList.remove("is-preset", "is-empty", "flash-correct", "flash-wrong");
          continue;
        }
        if (blankTargets.includes(i)) {
          clearPromptBlank(i);
          continue;
        }
        const letter = availableLetters[i] ?? availableLetters.shift() ?? alphabet[Math.floor(Math.random() * alphabet.length)];
        const symbol = getSymbol(letter);
        cell.dataset.letter = letter;
        cell.textContent = symbol;
        cell.classList.add("is-preset");
        cell.classList.remove("is-empty");
        cell.classList.add("is-visible");
        cell.setAttribute("aria-label", `Prompt symbol ${letter}, symbol ${symbol}`);
      }
    }

    function clearPromptBlank(index) {
      const cell = promptCells[index];
      cell.textContent = "";
      delete cell.dataset.letter;
      cell.classList.add("is-empty");
      cell.classList.remove("is-preset");
      cell.classList.add("is-visible");
      cell.setAttribute("aria-label", `Prompt blank ${index + 1}`);
    }

    function syncPromptRender() {
      clearPromptFlashes();
      setPromptBase();
      stages.forEach((stage, idx) => {
        const filled = stageIndex > idx;
        if (filled) {
          updatePromptCell(stage.targetIndex, stage.answer);
        } else {
          clearPromptBlank(stage.targetIndex);
        }
      });
      markActiveBlank();
    }

    function markActiveBlank() {
      promptCells.forEach((cell) => cell.classList.remove("is-active-blank"));
      const stage = stages[stageIndex];
      if (!stage) return;
      const cell = promptCells[stage.targetIndex];
      if (cell) cell.classList.add("is-active-blank");
    }

    function resetPromptState() {
      stages = buildStages();
      stageIndex = 0;
      document.documentElement.style.setProperty("--prompt-cols", promptSlots);
      syncPromptRender();
      setOptions(stages[0].answer);
      showFeedback("");
    }

    function handleChoice(letter) {
      const stage = stages[stageIndex];
      if (!stage) return;
      const symbol = getSymbol(letter);

      if (letter === stage.answer) {
        showFeedback(`${symbol} was the correct prediction`, true);
        flashPrompt("correct");
        updatePromptCell(stage.targetIndex, letter);
        disableChoices();

        setTimeout(() => {
          stageIndex += 1;
          const nextStage = stages[stageIndex];
          markActiveBlank();
          if (nextStage) {
            setOptions(nextStage.answer);
          } else {
            showFeedback("Sequence complete", false);
          }
        }, 900);
      } else {
        showFeedback(`Not ${symbol}. Try again.`, false);
        flashPrompt("wrong");
      }
    }

    choiceButtons.forEach((btn) => {
      btn.addEventListener("click", (e) => {
        if (btn.hidden) return;
        const letter = e.currentTarget.dataset.letter || e.currentTarget.textContent.trim();
        handleChoice(letter);
      });
    });

    function regenerateBoard({ animate = true } = {}) {
      generationId += 1;
      activeGenerationId = generationId;
      rowAddQueue = Promise.resolve();
      resetGridToBaseRows();
      applyLayoutVars();
      updateSequencesForMode();
      chooseBlankTargets();
      resetSequenceUsage();
      const newBoard = buildBoard();
      ensureAnswersPresent(newBoard);
      ensureNoiseDiversity(newBoard);
      if (!newBoard) return;
      currentBoard = [...newBoard];
      // new symbol mapping per generation
      currentSymbolPool = symbolSets[selectedSymbolSet] || symbolSets.geometric;
      buildSymbolIndexMap();
      resetPromptState();
      if (animate) {
        animateRenderBoard(currentBoard);
      } else {
        // ensure rows exist for instant render
        dataGrid.innerHTML = "";
        gridCells = [];
        for (let r = 1; r <= rowCount; r++) {
          const { row, cells } = createRow(r);
          dataGrid.appendChild(row);
          gridCells.push(...cells);
          revealRow(row);
        }
        renderBoardInstant(currentBoard);
      }
    }

    const markovBtn = document.querySelector('[data-action="markov"]');
    const turingBtn = document.querySelector('[data-action="turing"]');
    const cordellBtn = document.querySelector('[data-action="cordell"]');
    const symbolBtns = Array.from(document.querySelectorAll('[data-symbol]'));
    const generateBtn = document.querySelector('[data-action="generate"]');

    const modeDefaults = {
      markov: "geometric",
      turing: "runic",
      cordell: "runic",
    };

    function setSymbolSet(name, { refresh = true } = {}) {
      if (!symbolSets[name]) return;
      selectedSymbolSet = name;
      currentSymbolPool = symbolSets[name];
      symbolBtns.forEach((btn) => {
        btn.classList.toggle("is-active", btn.dataset.symbol === name);
      });
      if (refresh) {
        refreshSymbolsInView();
      }
    }

    function setModeLayout(mode) {
      if (mode === "turing") {
        baseRows = turingBaseRows;
        columns = turingColumns;
        promptSlots = 6;
        currentPromptLetters = [...turingPromptLetters];
        stageAnswers = ["D", "E"];
      } else if (mode === "cordell") {
        baseRows = 6;
        columns = 7;
        promptSlots = 7;
        currentPromptLetters = [...cordellPromptLetters];
        stageAnswers = ["D", "E", "F"];
      } else {
        baseRows = defaultBaseRows;
        columns = defaultColumns;
        promptSlots = 5;
        currentPromptLetters = [...defaultPromptLetters];
        stageAnswers = ["D", "E"];
      }
      applyLayoutVars();
    }

    function setAccent(mode) {
      if (!document.body) return;
      document.body.classList.remove("accent-markov", "accent-turing", "accent-cordell");
      document.body.classList.add(`accent-${mode}`);
      currentAccent = mode;
      setModeLayout(mode);
      updateSequencesForMode();
    }

    if (markovBtn) {
      markovBtn.addEventListener("click", () => {
        setAccent("markov");
        setSymbolSet(modeDefaults.markov);
        regenerateBoard({ animate: true });
      });
    }
    if (turingBtn) {
      turingBtn.addEventListener("click", () => {
        setAccent("turing");
        setSymbolSet(modeDefaults.turing);
        regenerateBoard({ animate: true });
      });
    }
    if (cordellBtn) {
      cordellBtn.addEventListener("click", () => {
        setAccent("cordell");
        setSymbolSet(modeDefaults.cordell);
        regenerateBoard({ animate: true });
      });
    }

    const devBtn = document.querySelector('[data-action="dev"]');
    const devMenuBtn = document.querySelector('[data-action="dev-menu"]');
    const devMenu = document.querySelector('[data-dev-menu]');
    const devViewSelect = document.querySelector('[data-dev-view]');
    const devSeqInput = document.querySelector('[data-dev-seq]');
    const devMutInput = document.querySelector('[data-dev-mut]');
    const devCheatInput = document.querySelector('[data-dev-cheat]');
    const devSeqDefault = document.querySelector('[data-dev-seq-default]');
    const devMutDefault = document.querySelector('[data-dev-mut-default]');
    if (symbolBtns.length) {
      symbolBtns.forEach((btn) =>
        btn.addEventListener("click", () => {
          const target = btn.dataset.symbol;
          setSymbolSet(target);
        })
      );
    }

    if (generateBtn) {
      generateBtn.addEventListener("click", () => {
        regenerateBoard({ animate: true });
      });
    }

    if (addRowBtn) {
      addRowBtn.addEventListener("click", () => {
        const queuedGeneration = generationId;
        rowAddQueue = rowAddQueue.then(
          () =>
            new Promise((resolve) => {
              if (queuedGeneration !== generationId) {
                resolve();
                return;
              }
              // Keep extra-row generation serialized so animations don't overlap.
              const { rowIndex, rowEl } = appendRow();
              const letters = generateRowLetters();
              if (!Object.keys(symbolIndexMap).length) {
                buildSymbolIndexMap();
              }
              const startIndex = rowIndex * columns;
              for (let i = 0; i < columns; i++) {
                currentBoard[startIndex + i] = letters[i];
              }
              const startDelay = extraRowDelay;
              setTimeout(() => {
                if (generationId !== activeGenerationId) {
                  resolve();
                  return;
                }
                revealRow(rowEl);
                animateRowFill(rowIndex, letters, 0);
              }, startDelay);
              const rowCompleteDelay = startDelay + cellDelay * columns + 40;
              setTimeout(resolve, rowCompleteDelay);
            })
        );
      });
    }

    function rerenderView() {
      if (!currentBoard.length) return;
      clearFillTimeouts();
      renderBoardInstant(currentBoard);
      syncPromptRender();
      if (stageIndex >= stages.length) {
        disableChoices();
      } else {
        setOptions(stages[stageIndex].answer);
      }
    }

    function updateRowBands(row) {
      if (!row) return;
      const layer = row.querySelector(".selection-layer");
      if (!layer) return;
      const cells = Array.from(row.querySelectorAll(".symbol-cell"));
      const runs = [];
      let start = null;
      cells.forEach((cell, idx) => {
        const selected = cell.classList.contains("is-selected");
        if (selected && start === null) start = idx;
        if (!selected && start !== null) {
          runs.push([start, idx - 1]);
          start = null;
        }
      });
      if (start !== null) runs.push([start, cells.length - 1]);

      const existing = Array.from(layer.children).reduce((list, band) => {
        if (!(band instanceof HTMLElement)) return list;
        const [bs, be] = (band.dataset.range || "").split("-").map((n) => Number(n));
        if (!Number.isNaN(bs) && !Number.isNaN(be)) {
          list.push({ band, start: bs, end: be });
        }
        return list;
      }, []);

      const inset = 4;
      runs.forEach(([s, e]) => {
        const first = cells[s];
        const last = cells[e];
        if (!first || !last) return;
        const minLeft = first.offsetLeft;
        const maxRight = last.offsetLeft + last.offsetWidth;
        const top = first.offsetTop;
        const height = first.offsetHeight;
        const width = Math.min(maxRight - minLeft + inset * 2, row.clientWidth);
        const bandHeight = height + inset * 2;
        const centerX = Math.max(minLeft - inset, 0) + width / 2;
        const centerY = Math.max(top - inset, 0) + bandHeight / 2;

        let matchIdx = -1;
        let bestOverlap = -1;
        existing.forEach((item, idx) => {
          const overlap = Math.min(e, item.end) - Math.max(s, item.start) + 1;
          if (overlap > bestOverlap && overlap > 0) {
            bestOverlap = overlap;
            matchIdx = idx;
          }
        });

        const band = matchIdx >= 0 ? existing.splice(matchIdx, 1)[0].band : document.createElement("div");
        if (!band.parentElement) {
          band.className = "selection-band";
          layer.appendChild(band);
          band.style.left = `${centerX}px`;
          band.style.top = `${centerY}px`;
          band.style.width = "0px";
          band.style.height = "0px";
          band.style.opacity = 0;
          band.style.transform = "translate(-50%, -50%) scale(0.7)";
        }
        band.dataset.range = `${s}-${e}`;
        requestAnimationFrame(() => {
          band.style.left = `${centerX}px`;
          band.style.top = `${centerY}px`;
          band.style.width = `${width}px`;
          band.style.height = `${bandHeight}px`;
          band.style.opacity = 1;
          band.style.transform = "translate(-50%, -50%) scale(1)";
        });
      });

      existing.forEach(({ band }) => {
        band.style.opacity = 0;
        band.style.transform = "translate(-50%, -50%) scale(0.7)";
        setTimeout(() => band.remove(), 260);
      });
    }

    function toggleCellSelection(cell, mode) {
      if (!cell) return;
      const row = cell.closest(".data-row");
      if (mode === "add") {
        cell.classList.add("is-selected");
      } else {
        cell.classList.remove("is-selected");
      }
      updateRowBands(row);
    }

    function getCellFromEvent(e) {
      const direct = e.target.closest?.(".symbol-cell");
      if (direct && direct.closest("[data-grid]")) return direct;
      const probe = document.elementFromPoint(e.clientX, e.clientY);
      if (!probe) return null;
      const viaPoint = probe.closest?.(".symbol-cell");
      return viaPoint && viaPoint.closest("[data-grid]") ? viaPoint : null;
    }

    function handlePointerDown(e) {
      if (!dataGrid) return;
      const isMousePrimary = e.pointerType === "mouse" ? e.button === 0 : true;
      if (!isMousePrimary) return;
      const cell = getCellFromEvent(e);
      const row = cell?.closest(".data-row");
      if (!cell || !row) return;
      e.preventDefault();
      isDraggingSelection = true;
      dragPointerId = e.pointerId;
      dragRow = row;
      dragSelectionMode = cell.classList.contains("is-selected") ? "remove" : "add";
      toggleCellSelection(cell, dragSelectionMode);
      dataGrid.setPointerCapture?.(e.pointerId);
    }

    function handlePointerMove(e) {
      if (!isDraggingSelection || e.pointerId !== dragPointerId) return;
      const cell = getCellFromEvent(e);
      if (!cell) return;
      const row = cell.closest(".data-row");
      if (!row || row !== dragRow) return;
      toggleCellSelection(cell, dragSelectionMode);
    }

    function endDrag(e) {
      if (!isDraggingSelection || (e && e.pointerId !== dragPointerId)) return;
      isDraggingSelection = false;
      dragPointerId = null;
      dragRow = null;
      dataGrid.releasePointerCapture?.(e?.pointerId);
    }

    function updateChoiceSymbols() {
      choiceButtons.forEach((btn) => {
        const letter = btn.dataset.letter;
        if (!letter) return;
        const symbol = getSymbol(letter);
        btn.textContent = symbol;
        btn.setAttribute("aria-label", `Option ${letter}, symbol ${symbol}`);
      });
    }

    function refreshSymbolsInView() {
      if (currentBoard.length) {
        gridCells.forEach((cell, idx) => {
          const letter = currentBoard[idx];
          if (!letter || !cell) return;
          const symbol = getSymbol(letter);
          cell.textContent = symbol;
          cell.setAttribute("aria-label", `${cell.dataset.baseLabel} contains letter ${letter}, symbol ${symbol}`);
        });
      }
      syncPromptRender();
      updateChoiceSymbols();
    }

    if (devBtn) {
      devBtn.addEventListener("click", () => {
        devMode = !devMode;
        devBtn.textContent = devMode ? "Letters" : "Symbols";
        rerenderView();
      });
    }

    if (devMenuBtn && devMenu) {
      devMenuBtn.addEventListener("click", () => {
        devMenu.classList.toggle("is-open");
        if (devMenu.classList.contains("is-open")) {
          const defaultSeq = currentAccent === "markov" ? 0.5 : currentAccent === "turing" ? 0.4 : 0.4;
          const defaultMut = currentAccent === "turing" ? 0.25 : currentAccent === "cordell" ? 0.35 : 0.15;
          devSeqInput.value = (customSeqChance ?? defaultSeq).toFixed(2);
          devMutInput.value = (customMutateChance ?? defaultMut).toFixed(2);
          const modeLabel = currentAccent.charAt(0).toUpperCase() + currentAccent.slice(1);
          if (devSeqDefault) devSeqDefault.textContent = `(default ${modeLabel} ${defaultSeq.toFixed(2)})`;
          if (devMutDefault) devMutDefault.textContent = `(default ${modeLabel} ${defaultMut.toFixed(2)})`;
          devViewSelect.value = devMode ? "letters" : "symbols";
          if (devCheatInput) devCheatInput.checked = cheatSeqGeneration;
        }
      });
    }

    if (devViewSelect) {
      devViewSelect.addEventListener("change", () => {
        const view = devViewSelect.value;
        devMode = view === "letters";
        currentSymbolPool = symbolSets[selectedSymbolSet] || symbolSets.geometric;
        rerenderView();
      });
    }

    const applyDevBtn = document.querySelector('[data-action="apply-dev"]');
    if (applyDevBtn) {
      applyDevBtn.addEventListener("click", () => {
        const seqVal = parseFloat(devSeqInput.value);
        customSeqChance = Number.isFinite(seqVal) ? Math.max(0, Math.min(1, seqVal)) : null;
        const mutVal = parseFloat(devMutInput.value);
        customMutateChance = Number.isFinite(mutVal) ? Math.max(0, Math.min(1, mutVal)) : null;
        cheatSeqGeneration = devCheatInput?.checked ?? false;
        devMenu.classList.remove("is-open");
      });
    }

    if (dataGrid) {
      dataGrid.addEventListener("pointerdown", handlePointerDown);
      dataGrid.addEventListener("pointermove", handlePointerMove);
      dataGrid.addEventListener("pointerup", endDrag);
      dataGrid.addEventListener("pointercancel", endDrag);
      dataGrid.addEventListener("pointerleave", endDrag);
      dataGrid.addEventListener("selectstart", (e) => {
        if (e.target.closest(".data-row")) e.preventDefault();
      });
    }

    // Build initial grid, stage, and board
    setAccent(currentAccent);
    initializeGrid();
    regenerateBoard({ animate: true });
  </script>
</body>
</html>
